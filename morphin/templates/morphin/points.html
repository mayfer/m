{% extends "morphin/base.html" %}
{% block head %}
	<script type='text/javascript'>
		(function($) {
		    $.fn.nextWrap = function() {
		        var $next = this.next();
		        return ($next.length === 0) ? this.siblings().first() : $next;
		    };
		
		    $.fn.prevWrap = function() {
		        var $prev = this.prev();
		        return ($prev.length === 0) ? this.siblings().last() : $prev;
		    };
		})(jQuery);
	
	
		marker = function() { return $("<div>").addClass('marker'); }
		master_points = function() { return $("<input type='text' name='master' >"); }
		slave_points = function() { return $("<input type='text' name='slave' >"); }
		
		count = 0;
		frames = 10;
		captureClick = function(e) {
		
			var themarker, thepicture, offset, box, has_moving;
			
			thepicture = $(this);
			themarker = $(this).parent().find('.marker.moving');	
			offset = thepicture.offset();
			box = thepicture.parent();

			// the point actually appears 4 pixels off in both axis.
			// however the point size is also 4 px, which puts the center at 2, so 4-2=2
			var left = (e.pageX - offset.left + 2), top = (e.pageY - offset.top + 2);
			
			if(themarker.length) {
				themarker.css( { "top": top, "left": left } );
			} else {
				if(box.hasClass('master')) count++;
				marker().appendTo(box).addClass('m-'+count).css( { "top": top, "left": left } );
				box.removeClass('current').addClass('inactive').nextWrap().addClass('current').removeClass('inactive');
			}
			
			$('#done').prop('disabled', false);
		}
		
		$(document).ready(function(){
			$('.picture.current img').live('mousedown', captureClick);
		
			
			$('#done').click(function(e){
				if($(this).prop('disabled') == false) {
					$('#done').html('Processing...').prop('disabled', true);
					$('#morph').html("<img src='{{ MEDIA_URL }}loader.gif' />");
									
					var postdata = {'markers': []};
					
					var master = $('.picture.master'), slave = $('.picture.slave');
					for(var i=1; i<=count; i++) {
						var marker_master = master.find('.marker.m-'+i);
						var marker_slave = slave.find('.marker.m-'+i);
						// for -2, see comment in captureClick
						var top_m = parseInt(marker_master.css('top'))-2, left_m = parseInt(marker_master.css('left'))-2;
						var top_s = parseInt(marker_slave.css('top'))-2, left_s = parseInt(marker_slave.css('left'))-2;
						postdata['markers'].push({
							'master': {'x': left_m, 'y': top_m },
							'slave': {'x': left_s, 'y': top_s }
						});
					}
					$.post(
						'{% url morphin:generate morph.id %}',
						{ 'data': JSON.stringify(postdata) },
						function(response) {
							if(response.status=='ok') {
								$('#final').show();
								$('#done').html('Preview').prop('disabled', false);
								$('#morph').html("<img src='"+response.image_url+"' />");
							} else {
								alert(JSON.stringify(response));
							}
						}, 'json'
					);
				}
			});
			
			$('#finalize').click(function(e){
				window.location = '{% url morphin:view morph.id %}';
			});
			
			$('body').keyup(function(e) { 
				if (e.keyCode == 27) {
					$('.marker.m-'+count).remove();
					if(count) count--;
					pick_pic();
				}
			});
			
			$('.marker').live('mousedown', function(e){
				e.preventDefault();
				var movingmarker = $(this);
				movingmarker.addClass('moving');
				var image = $(this).parent().find('img');
				var box = image.parent().addClass('crosshair');
				image.bind('mousemove', captureClick);
				box.one('mouseup', function(){
					image.unbind('mousemove');
					movingmarker.removeClass('moving');
					box.removeClass('crosshair');
				});
			});
		});
		function pick_pic() {
			var pic;
			$('#pictures .picture.master').addClass('current').removeClass('inactive').nextWrap().removeClass('current').addClass('inactive');
		}
		function log(text) {
			$('#imagick').append("\n"+text)
		}
		
		function generate_stage(frame, i, master, slave, stage) {
			var marker_master = master.find('.marker.m-'+i);
			var marker_slave = slave.find('.marker.m-'+i);
			
			var top_m = parseInt(marker_master.css('top')), left_m = parseInt(marker_master.css('left'));
			var top_s = parseInt(marker_slave.css('top')), left_s = parseInt(marker_slave.css('left'));
			
			var top_diff = (top_s - top_m), left_diff = (left_s - left_m);
			var top = parseInt(top_m + (top_diff * (frame/frames)));
			var left = parseInt(left_m + (left_diff * (frame/frames)));
			
			//return top_m+","+left_m+" "+top+","+left+"  ";
			return left_m+","+top_m+" "+left+","+top+"  ";
		}
	</script>
{% endblock %}

{% block content %}
	<div id='pictures'>
		<div id='hint'>
			starting with the left image,<br />click on points that you want to morph into each other.
		</div>
		<table class='points'>
			<tr>
				<td class='picture master current'><img src='{{ morph.master_image.url }}?points' /></td><!-- anticache -->
				<td class='picture slave inactive'><img src='{{ morph.slave_image.url }}?points' /></td><!-- anticache -->
			</tr>
		</table>
		<div class='tip'>more points yield better results.<br />also, hit escape to undo.</div>
		<button id='done' disabled='disabled'>Preview</button>
		<div id='morph'>
			{% if morph.morph_image %}
				<img src='{{ morph.morph_image.url }}' />
			{% endif %}
		</div>
		
		<div id='final' {% if not morph.morph_image %} style='display:none;' {% endif %}>
			<div class='tip'>when satisfied, caption and finalize</div>
			<form action='{% url morphin:view morph.id %}' method='post'>
				<textarea class='caption' name='caption'>Enter a caption. Or not.</textarea>
				<button id='finalize' type='submit'>Finalize</button>
			</form>
		</div>
	</div>
{% endblock %}